LESSONS :

- Consensus is the method that allows block creation and reward to miners. many type od consensus : POW (not green), POS, POA(proof of authority beter for private network)
- POW for eth and BTC
- Soon POS fro eth 
- POA : Proof of authority
- multiple type of wallets 
    - simple wallet
    - smart contract wallet 
        - Single owneship wallets
        - Multisig wallets:
            - created by one and owned by many. there is a daily limit action per owner, then every owners have to agree when one owner want to get over the limit
- centralized app have a backend central paid by the provider and central DB. 
- dApp has no backend, rather there is a backend called smart contract deployed on a decentralized network (a set of nodes, node being just laptops running the EVM)
- you create ur smart contract and you deploy it to the network. 
- someone can use your smartcontract by deploying this smart contract to his address. for that it need the JSON API provided by your smart contract.. awesome right ? 
- So primablock just deploy contract on network, then from a fromt end who use We3b3 it sends directly details to the network using the JSON API to deploy on a certain address ! this is sweet. 
- for your app to become dapp they need to connect to the decentralized network through a node. the ethereumwallet by example connect to the geth client. a chrome browser connect to the network through Metamask
- Deploying a node locally is expensive cause it needs to sync the whole network before launching your app. so it takes time. so for that u use metamask who is already ready 


SYNC WORK
- install geth 
- install geth with full node sync 
- install toml for vs just type toml
- dump conf 
- now u use geth --config toml.file  to download geth as is on original dev env
- set up rpcjson geth --testnet  --rpc --rpcaddr "localhost" --rpcport "8545" --rpcapi "web3,eth,net" --rpccorsdomain "*" --datadir "./data"




# launch geth or connect geth to the network and sync it
geth --rinkeby --identity "MyTestNode" --datadir "./data"  --verbosity "4" --fast (or full or light)

# obtains TOML config
geth dumpconfig

# load geth using a TOML file
geth --config tomlfile

# app connects to geth through json rpc, ipc rpc or ws rpcs

#  activate jsonRpc + cross domain
geth --rinkeby  --rpc --rpcaddr "localhost" --rpcport "8545" --rpcapi "web3,eth,net" --rpccorsdomain "*" --datadir "./data"

# for enabling ws it is similar to the abowe but just replace by : ws insteadf of rpc

# geth provide js api for : eth, miner, admin, personal, web3


# launch geth with interactive console
geth --rinkeby --verbosity "4" --datadir "./data"  console

# attach to an existing interactive geth. u can attach in jsonRpc (http...8545) or wsrpc (ws://...8546)
geth --datadir "./data" --rinkeby attach "./data/geth.ipc"  (<--- this adress shows when u already launched in console verbosity 3 minimum)


#preload scripts before launching of geth so that once loaded we can call variables and functions in it
geth --rinkeby --verbosity "0" --datadir "./data"  --preload "./scripts/utils.js" console
# just replace preload by exec and provide a js command. this will execute the commnd show result and terminate geth client

# list geth accounts
geth  --rinkeby --datadir "./data"  account list

# creates geth account
geth  --rinkeby  --datadir "./data" account new

# provide :  --unlock "0"  to unlock first account and provide at the prompt the password or provide it thourgh a file

# modules: admin:1.0 clique:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0
# web3 provides api in jsonrpc api or console mode: eth, net, shh, db  in interactive and non interactive modes
# net.listening : to show if client is listening
# there is also the management API  provides other api :  admin (node management)   personal (creates new account...)  miner (start mining)
# debug (debug ur dapp) txpool (transaction pool)


# admin object API when geth launched in RPC mode
admin.nodeinfo
admin.datadir
admin.peers : to check if peers are connected to our node and thus if the nodes is really in the network
addPeers(url) : to add a node
admin.startRPC("localhost", 8545, "RPC")
admin.stopRPC()
admin.startWS
admin.setSolc(path to solidity compiler


# personal object API
personal.ListAccounts
personal.new("password")
personal.importRawKey(keydata, passphrase)
never do this : geth CLI --unlock option : cause everyone can attach and thus make some send
rather do this : personal.unlockAccount() ..... personal.lockAccount()
you can send ether by doing this: personal.sendTransaction(txn_object, paraphrase)
txn {from addr   ,  to addr,  value in wei: web3.wei(1)  (convert 1 eth to wei)}


# miner object API

# Nonce is just a number sayoing the number of send that took place in that wallet

# txpool object API
.status
.inspect
.content

# load scripts before attaching to already running geth console
geth  --exec "loadScript('./web3api/%1')" attach "http://localhost:8545"

# creates private dev network
geth --dev --datadir "./data" --rpc --rpcaddr "localhost" --rpcport "8545" --rpcapi "web3,eth,net,personal" --rpccorsdomain "*"

# Validate Solidity before attach
geth   --exec "loadScript('./web3api/validateSolidity.js')" attach "http://localhost:8545"


# to connect your app to the eth network u need libraries :
web3js, nethereum(.net), web3j(java https://docs.web3j.io/getting_started.html), web3py(python https://github.com/pipermerriam/web3.py)

# web3js details    api https://github.com/ethereum/wiki/wiki/JavaScript-API
- for the function u always have :  function (error, succes)  u have to handle error first then the success case
- js cant handle big number. so it uses a library called bignumber: https://github.com/MikeMcl/big.js/ but even there it cant manage number with more than 20 floating point. so manage account balance in wei

# connect in ssh
# ssh -i "scm.pem" ubuntu@ec2-18-191-249-239.us-east-2.compute.amazonaws.com

# u can deploy using web3
# contract deployment is like atransaction.
# the contract is available after the transaction has been mined
# u have to pay for it
# it is part of the ledger now
# u use eth.contract  to deploy or calling methods of the contract or watch for events from contract instance.
# to deploy u need to call the new method (async or sync)

# events exist and are broadcasted to the whole network
# it is used to receive data for transaction
# or async trigger
# or cheap data storage

# Ganache is an eth simulator. it helps u to code deploy without waiting mining the transaction ... really straight forward
# mocha and chai are framework for test and assertion respectively

# truffle boxes are pre built project for truffle that dev dcan download and integrate in their own project
# to use boxe:
# create folder with name of the box.
# get in dir and then exec : truffle unbox box_name
# run ganache.  provide conf for client : Ganache.  execute truffle migrate .  execute truffle test


# truffle cli is used for 
prject scaffolding 
solidity code  compilation
Unit testing 
deployment
automat contract testing with mocha and chai
automate deployment and migration of contract 
interactive console with deployed contracts :: awesome no need to send a transaction 


to compile truffle compile
to deploy your contract you just have to do :
truffle migrate 
and to test :
truffle test 
interact with the contract :  truffle console    it connects to an existing blockchain here the one of ganache.
You use the Boxes as starting point for your own project 


######################Steps to develop a contract with truffle:######################
- setup the project 
    - init truffle project
        + create a directory for the project
        + get init 
        + call truffle init
    - contract skeleton
        + create contract skeleton :  truffle create contract "name of contract"
        + truffle compile
    - update deploy config file
        + add the file 2_deploy_contracts.js into the folder : migrations. To do that just copy the file from an existing box [[REF 1]]
        + update this file to reflect the current project 
    - migrate or deploy
        + EXECUTE truffle migrate : reads the file under the migrations folder and then based on config in that file it deploys it unto the eth client.
- iterative dev of the contract
    - You need the specifications of the contract
    - You need to know how it is supposed to work 
    - Now you need to do test driven development so you : Add The Test Cases 
        + to create test u type : truffle create test "name of contract"
        + to run the test type : truffle test ./test/projectname.js
    - Code contract
        + think like a class with functiins as actions
    - Compile contract
        + truffle compile
        + truffle migrate 
    - Test Contract against the test cases on ganache 
        + truffle test 
    - Repeat until you are done and all test passes. Remember for new features first u write the tests then u code then u test against the tests till they pass
- deploy to the eth network
    - after successfull test done after deployment on local ganache then deploy on the next env : QA ENV : TESTNET by example or  RINKEBY
    - After complete test in QA it is deployed to : LIVE NETWORK. here u can deploy on locl node, private network or REMOTE NODE !!
    - multiple tools to deploy the contracts : ETH WALLET OR REMIX but the best ways are :  SCRIPTS THAT WILL COMPILE AND DEPLOY. TRUFFLE MIGRATE IS ANOTHER TOOL TO DEPLOY
    - TRUFFLE MIGRATE 
        + --reset to force the contract to be redeployed
        + -f number : run contracts from a specific igration
        + to create another config file for deployment we do : truffle create migration deploy_contracts. that helps u to deploy with different init configuration. to use it do : truffle migrate -f number of the file previously created 
        + -- compile-all
        + --verbose-rpc
        + --network name : u can deploy locally, or on the QA or on live network
            = check truffle.js or truffleconfig.js
            = the name are specified in this file. 
            = u can create thus multiple conf giving them each names to be specified in command line
            = deploy takes gas so u have these options available :  gas , gas price from eth adre to take the funds.
            = use truffle 


[[REF 1]]####################################################################
// #1 Get an instance of the contract to be deployed/migrated
var Calculator = artifacts.require("./Calculator.sol");
var CalculatorV2 = artifacts.require("./CalculatorV2.sol");

module.exports = function(deployer) {
  // #2 Deploy the instance of the contract
  deployer.deploy(Calculator);//, 10);
  deployer.deploy(CalculatorV2, 10);
};
##############################################################################

# a contract is layout as :
pragma to specify version of compiler to use 
contract === classstate/storage var 
events 
functions

# a contract can : invok  inherit create another contract
# u can import contract from another file or over http or github 


# as value type : 
 - boolean, init at false by default
 - integer (uint8, uint32, uint16,) all initialized at 0 or false,
 - Address : 20byte eth adre. method : transfer and send 

# in memory you have 3 places where u can store : 
    - storage
        - it is a database with key value store 256 bit
        - expensive to store here cause it uses gas to read and write in there.
        - u can store in there function or variables
        - used to persist data 
        - Local variable and class variables are stored there. 
        - dynamic arrays goe there 
        - var declared outside of funcs goes straight there
        - you can specify with keyword : storage
    - memory
        - temporary
        - for arrays and struct 
        - specify with the keyword : memory 
    - calldata
        - code execution 
        - size limited at 1024 or word 256 bit. if ur code calls too muchfunction calling each other u can have then a stack overflow exception 
        - not changeable 

u can specify in a function params if u want the params passed to ur function to be in storage or memory 
dynamic arrays size can be set at runtime

u can have then 

# static array 
bool[10] array    uint[10] array  
u cant do array.push
array.length or u cant do array = [1,2,3] 

# dyn arrays 
int8[] arr  --> goes in storage      array = new int8[](10)  u czn do array.push(5)
int8[] memory array --> memory    array = new int8[](10)     u cant do array.push

static array can be put in memory or storage but dynamic aarrays can only be put in storage 


# contracts that are deployed on the publick network are constantly under attack 
# so u have to make sure that they cant hack it, make it hackerproof
# Peer code reviews
# coding standarrds such as naming and styling 
# Testing testing testing : it is never enough : think like an hacker
identify the flaws very soon 
# a getter can not change the value of a contract 
USE : VIEW AND PURE    or Modifiers like : public, private, internal, external.
VIEW : allows u to read the storage but not modify it : so no state changes
PURE : u can not read and no modify : no state changes
the copiler will giove u warnings 
What causes a state change : 
setting value in storage variable 
emitting of events from function 
creatings a new contract instance 
sending ethers 
using low level calls 
using selfdestruct


#error handling 
you can have 
Runtime errors 
    - thrown by EVM/Ops
and
Application error :
    - Developer decides to return it through return value   or   Emit Event    or throw an exception (best way)
    - there is no try catch 
    - when there is exception there is a full rollback no eth sent, eth received are refunded, gas is spent and recorded 
    - Revert() function : throws exception and return unused gas
    - require(condition)  : unused gas returned : revert style : used to tell the caller that there is an exception 
    - assert(condition) : all gas consumed : to catch bug in your own code : used for your own internal test : divide by 0 or negative array index .... 
      so you can use assert in your code or at the end of your code to make sure that there is no bug in your code and that some variable at the end of a function is always greater than 0 by example

Hashing
Mapping
Enumeration
struct 
reference

object orientstion programmation


VIsibility variable and function:
    - public : by def function is public
        - if u dont specify the visibility then it is by def public
        - part of the abi
        - automatic getter for state var  
        - accessible from outside the contract
    - private : not available outside this contract only within the contract. 
        - available only within the contract and not even in derived contract 
    - internal 
        - within the contract and the derived contract 
        - storage var are internal by default
        - internal function can not be invoked outsidethe contract but can be called from derived contract 
    - external : does not apply to storage variable: can be inb=voked from within using this. called naturally from outside.
        - only on func 
    - this
    - function type :used with function , internal or external, constant, payabble , returns


# Constant variable 
    - only allowed for storage value and function
    - it doesnt change the state 
    - can not be initialized in constructor
    - not for struct, only for basic type and string  


# fallback function 
    - an unamed function in the contract 
    - invoked without data : no signature 
    - no args 
    - cant return anything 
    - max gas spent : 2300 gas : u can not update storage or execute loops or invoke other contract 
    - a function that has no name and no return 
    - no name , no param 
    - only one per contrct 
    - in fall back just log an event and nothing else 

# Receiving Ethers 
    - a contract can receibe ether by way of fallback function 
    - it is invoked when ethers are receivded (msg.value) without data means without contract signature. 
    - msg.value is only available in payable function 
    in fall back just log an event and nothing else 
    - a function must be marked as payable to receive ethers 


    # Modifiers

    # events
    events are stored in the log and if dapp is listening then they will receive event 
    events are stored in logs 
    logs can e read using filters. only a max of 3 index arguments can be used to filter. 
    to declare them is like function without body 


    # self destruction pattern 
        - contract lifecycle 
            - develop    Deployed     invoked    Self destruct 
        - needed when business need it. bidding over, loan over ....
        - to use it function killcontract() OwnerOnly {
            suicide(owner); // send at the address of owner 
        }
        - if u send funds to a destroyed contract transaction will fail , and contract lost 
            - to avoid loss, remove all ref to dead contracts 
            - or call get before send to ensure contrct is NOT dead.

    # Factory pattern 




Goal of the backend service
We want to design a backend, that addresses blockchains shortcomings. Main points we want to achieve with our service:

Get data from the blockchain and stores it into easier to access database.
Performs data analysis and data manipulation.
Designed for data recovery from the blockchain.
Event based design, which should work with multiple blockchain data inputs (RPC and WebSocket).
Transactions can get rejected or removed because of an uncle block. Service has to be robust enough to handle that.
Blockchain will be data generator and decision maker. It directly processes user made transactions and stores historical
 transactions data. Backend service will parse blockchain created data and present it to the web. That way we provides faster 
 and much better user experience.


###############   REACT REDUX REACT AUTH   ###############

REACT helps us to write or create a website using a system of components.

Components will be JSX files (JS + HTML). those components will generate code that will be inserted in the DOM : what the user sees. so it is JS that generated HTML

for each page or window we can cut the page in pices, and the searchbar being a componenet and each lil part being a components
and a list is a component and each element bein component of the file.

so always one component per file. so u can reuse it as u wish








